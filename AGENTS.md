# Agent Instructions

## Project Overview

`wp-astrojs-integration` is an npm package that provides WordPress integration for Astro.js. It includes:

- **WordPressClient** (`src/client/`) — typed HTTP client for the WP REST API
- **Static loaders** (`src/loaders/static.ts`) — build-time data fetchers for `defineCollection`
- **Live loaders** (`src/loaders/live.ts`) — runtime data fetchers for `defineLiveCollection`
- **Zod schemas** (`src/schemas/`) — validation schemas for all WP entities
- **Astro components** (`src/components/`) — `WPContent.astro`, `WPImage.astro`

## Testing

### Philosophy

- **Integration tests only** — no unit tests. Every test runs against a real WordPress instance.
- Tests exercise the full stack: TypeScript code -> HTTP -> WordPress REST API -> response validation.
- This catches real-world issues (serialization, pagination caps, auth flows) that mocks would miss.

### Test infrastructure

| Component | Purpose |
|---|---|
| `@wordpress/env` | Spawns a local WordPress Docker container |
| `Vitest` | Test runner (config in `vitest.config.ts`) |
| `.wp-env.json` | wp-env config — PHP version, mu-plugin mappings, lifecycle scripts |
| `tests/wp-env/mu-plugins/` | Must-use plugins mounted into the WP container |
| `tests/wp-env/seed-content.php` | Idempotent PHP script that generates all test content on startup |
| `tests/setup/global-setup.ts` | Vitest globalSetup — waits for WP API, creates app password |
| `tests/setup/env-loader.ts` | Vitest setupFile — reads `.test-env.json` into `process.env` for workers |
| `tests/helpers/` | Shared test utilities (mock store, mock logger, WP client factories) |

### Seed data

Test content is generated by `tests/wp-env/seed-content.php`, which runs automatically on every `wp-env start` via the `afterStart` lifecycle script in `.wp-env.json`. The script is idempotent — it checks for existing content before creating, so repeated starts are safe.

#### Contents

| Entity | Count | Details |
|---|---|---|
| Categories | 5 (+1 Uncategorized) | Technology, Science, Travel, Food, Health |
| Tags | 8 | featured, trending, tutorial, review, guide, news, opinion, update |
| Posts | 150 | "Test Post 001" – "Test Post 150" (slugs: `test-post-001` – `test-post-150`) |
| Pages | 10 | About, Contact, Services, FAQ, Team, Blog, Portfolio, Testimonials, Privacy Policy, Terms of Service |
| Books (CPT) | 10 | "Test Book 001" – "Test Book 010" (slugs: `test-book-001` – `test-book-010`; registered by `tests/wp-env/mu-plugins/register-book-cpt.php`, rest_base: `books`) |

#### Post distribution

| Posts | Category | Tags |
|---|---|---|
| 1–30 | Technology | featured, tutorial |
| 31–60 | Science | trending, news |
| 61–90 | Travel | guide, review |
| 91–120 | Food | opinion, update |
| 121–150 | Health | featured, news |

#### Modifying seed data

1. Edit `tests/wp-env/seed-content.php`
2. Destroy and restart the environment: `npm run wp:clean && npm run wp:start`
3. Update test assertions to match the new seed data counts/slugs

### Running tests

```bash
npm run wp:start   # Start WordPress Docker container (required once, seeds data automatically)
npm test           # Run all integration tests
npm run test:watch # Run in watch mode
npm run wp:stop    # Stop the container
npm run wp:clean   # Destroy container and volumes
```

### How to write new tests

1. **Always write integration tests**, not unit tests. Test against the real WP REST API.
2. Place tests in `tests/integration/client/` for `WordPressClient` methods, `tests/integration/loaders/` for loader functions, or `tests/integration/actions/` for server actions.
3. Use the helpers in `tests/helpers/`:
   - `createPublicClient()` / `createAuthClient()` from `wp-client.ts` for API access
   - `createMockStore()` from `mock-store.ts` for static loader tests
   - `createMockLogger()` from `mock-logger.ts` for static loader tests
4. One test file per resource type (posts, pages, categories, tags, media, users, settings).
5. Test both success paths and error paths (e.g., non-existent slug returns `undefined`, unauthenticated request throws).
6. Use exact counts and known slugs from the seed data rather than dynamic discovery.
7. Static loaders need a mock `store` (with `clear` and `set` methods) and a mock `logger` (with `info`, `error`, `warn`). They write to the store; assert on the store contents.
8. Live loaders return plain objects from `loadCollection()` / `loadEntry()`. Assert on the returned data directly.

### Testing server actions

Server actions expose two layers:
- `createXxxAction(config)` — returns an Astro `ActionClient` for use at runtime (requires the Astro framework).
- `executeXxx(config, input)` — the raw async handler, exported separately for direct use in integration tests without the Astro runtime.

Always test via the `execute*` functions:

```ts
import { executeCreatePost } from '../../../src/actions/post/create';
import { executeUpdatePost } from '../../../src/actions/post/update';
import { executeDeletePost } from '../../../src/actions/post/delete';
import { createBasicAuthHeader } from '../../../src/client/auth';
import { getBaseUrl } from '../../helpers/wp-client';

// Posts (default — resource can be omitted)
const config = {
  apiBase: `${getBaseUrl()}/wp-json/wp/v2`,
  authHeader: createBasicAuthHeader({ username: 'admin', password: process.env.WP_APP_PASSWORD! }),
};

// Pages — set resource to 'pages'
const pageConfig = { ...config, resource: 'pages' };

// Custom post types — set resource to the CPT rest_base
const bookConfig = { ...config, resource: 'books' };
```

Key patterns for action tests:
- Track created post IDs in a shared array and clean up in `afterAll` using `executeDeletePost({ force: true })` to avoid polluting the environment.
- Verify that unauthenticated calls throw `ActionError` (import from `astro/actions/runtime/server.js`).
- `deletePostInputSchema` accepts an optional `force` field — `true` = permanent delete, omit/`false` = trash.
- Test both trash (`deleted: false`) and permanent delete (`deleted: true`) paths.
- For pages and CPTs, pass the appropriate `responseSchema` to create/update if you need typed response parsing (e.g. `pageSchema` for pages, `contentWordPressSchema` for generic CPTs).

### What to test when adding new features

- **New client method**: Add tests to the appropriate file in `tests/integration/client/`. Cover: returns data, required fields present, pagination, slug lookup, error cases.
- **New static loader**: Add tests to `tests/integration/loaders/static-loaders.test.ts`. Cover: populates store, correct keys, rendered HTML presence (for content types).
- **New live loader**: Add tests to `tests/integration/loaders/live-loaders.test.ts`. Cover: `loadCollection` returns entries, `loadEntry` by slug, `loadEntry` by id, error for non-existent entry.
- **New server action**: Add tests to the entity-specific file in `tests/integration/actions/` (e.g. `posts.test.ts`). Cover: success path, field values, auth enforcement (`ActionError`), and non-existent resource error.
- **New WP entity/resource (actions)**: The `execute*` functions and `create*Action` factories are generic — pass `resource` to target any REST endpoint. No new source files are needed for pages or CPTs. Add a matching `tests/integration/actions/<entity>.test.ts` with `resource` set to the entity's `rest_base`.

### wp-env lifecycle

The `.wp-env.json` file configures:
- **`mappings`**: Mounts `tests/wp-env/mu-plugins/` and `tests/wp-env/seed-content.php` into the container's `wp-content/` directory.
- **`lifecycleScripts.afterStart`**: Runs after `wp-env start` — configures permalink structure and runs the seed content script. This ensures every fresh environment has identical test data.

### CI pipeline

Integration tests run automatically via GitHub Actions (`.github/workflows/tests.yml`) on:
- Pull requests targeting `main`
- Pushes to `main`

The workflow uses `ubuntu-latest` (Docker pre-installed), sets up Node 22, installs dependencies, starts wp-env, and runs the test suite.

### Key gotchas

- `wp-env` output includes status lines (ℹ/✔). The `wpCli()` helper in `global-setup.ts` strips these. Always use it instead of raw `execSync`.
- Vitest `globalSetup` runs in a separate process — `process.env` changes do NOT propagate to test workers. Env vars are bridged via `.test-env.json` (written by globalSetup, read by `env-loader.ts` setupFile).
- WordPress application passwords require HTTPS by default. The mu-plugin at `tests/wp-env/mu-plugins/enable-app-passwords.php` overrides this for HTTP localhost.
- The WP REST API caps `per_page` at 100. Use `getAll*()` methods for full pagination instead of setting high `perPage` values.
- WordPress creates a default "Privacy Policy" page in draft status. The seed script detects this and publishes it to ensure 10 pages are available.
- The `afterStart` lifecycle script runs on the HOST, not inside the container. It uses `npx wp-env run cli -- wp ...` to execute WP-CLI commands inside the container.

## Code Style

Follow the rules in the global `AGENTS.md` (clean code, exit early, DRY, English comments). Additionally:

- Schemas live in `src/schemas/` — one file per concern.
- Client methods live in individual files under `src/client/` (e.g., `posts.ts`, `pages.ts`).
- Loaders are split into `src/loaders/static.ts` and `src/loaders/live.ts`.
- All public API is re-exported from `src/index.ts`.

## npm Package

The `files` field in `package.json` is an allowlist: only `dist/` and `src/components/` are published. Test files, wp-env config, and vitest config are excluded automatically. When adding new directories, verify they are not unintentionally included by running `npm pack --dry-run`.
